---
categories:
- c-cpp
date: '2026-01-24'
tags:
- 자료 구조
- STL
- C++
- 튜플
title: '[C++] Tuple'
toc: true
toc_sticky: true
---

## **1. 개요**

`std::tuple`은 서로 다른 타입의 여러 값을 하나의 객체로 묶는 자료
구조입니다. 개수와 타입이 고정된 heterogeneous container 역할을 하며
`<tuple>` 헤더에 정의되어 있습니다.

{% raw %}
```c++
 #include <tuple>
 tuple<int, double, string> t(10, 3.14, "hello");
```
{% endraw %}

## **2. 주요 특징**

- 서로 **다른 타입**을 하나의 객체로 묶을 수 있음
- 요소 접근은 `std::get<index>` 사용
- 요소 개수는 컴파일 시 고정
- 비교 연산자 제공 (==, !=, < 등)
- `make_tuple`, `tie`, `tuple_cat` 등의 유틸리티 제공
- 구조화 바인딩(C++17)과 함께 사용 가능
## **3. 주요 멤버 함수 / 관련 함수**

| 함수 / 템플릿 | 설명 |
| --- | --- |
| `tuple<T...>` | 튜플 생성 |
| `make_tuple(args...)` | 타입 추론 기반 튜플 생성 |
| `get<Index>(tuple)` | 특정 index 요소 접근 |
| `tuple_size<T>::value` | 튜플 요소 개수 |
| `tuple_element<Index, T>::type` | 특정 인덱스 요소 타입 |
| `tie(vars...)` | 참조 튜플 생성 (언패킹 용도) |
| `forward_as_tuple(args...)` | perfect forwarding용 튜플 |
| `tuple_cat(t1, t2, ...)` | 여러 튜플을 이어 붙여 새로운 튜플 생성 |
| 비교 연산자 | `==`, `!=`, `<`, `>` 등 사전식 비교 가능 |

## **4. 예제 코드**

### **기본 사용**

{% raw %}
```c++
 #include <iostream>
 #include <tuple>
 using namespace std;
 
 int main() {
   tuple<int, double, string> t(10, 3.14, "hello");
 
   cout << get<0>(t) << endl;
   cout << get<1>(t) << endl;
   cout << get<2>(t) << endl;
 
   return 0;
 }
```
{% endraw %}

### **`make_tuple`**** + 구조화 바인딩**

{% raw %}
```c++
 auto t = make_tuple(1, 2.5, "abc");
 
 auto [a, b, c] = t;
 
 cout << a << ", " << b << ", " << c << endl;
```
{% endraw %}

### **`tie`****를 이용한 언패킹**

{% raw %}
```c++
 int x;
 double y;
 string z;
 
 tuple<int, double, string> t(3, 1.5, "hi");
 tie(x, y, z) = t;
 
 cout << x << ", " << y << ", " << z << endl;
```
{% endraw %}

### **`tuple_cat`**

{% raw %}
```c++
 auto t1 = make_tuple(1, 2);
 auto t2 = make_tuple(3.14, "hello");
 
 auto t3 = tuple_cat(t1, t2);
 // t3 → (1, 2, 3.14, "hello")
```
{% endraw %}

## **5. **`std::tuple` vs `std::pair`

| 항목 | `std::tuple` | `std::pair` |
| --- | --- | --- |
| 요소 개수 | 여러 개 | 2개 |
| 요소 접근 | `get<index>` | `first`, `second` |
| 유연성 | 높음 | 2개일 때만 적합 |
| 가독성 | 인덱스로 접근해 다소 낮을 수 있음 | 명확함 |

## **6. 주의사항**

- 인덱스는 **컴파일 시간 상수**여야 함 → 런타임 인덱스 접근 불가
- 요소 접근은 반드시 `get<Index>()` 사용
- 너무 많은 요소를 담으면 가독성 저하
- 참조를 저장하려면 `tie` 또는 `reference_wrapper` 필요
- 타입 추론 시 `make_tuple` 사용 권장

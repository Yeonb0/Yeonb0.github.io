---
layout: single
title: "[BOJ] 18352 - 특정 거리의 도시 찾기"
categories:
  - BOJ
  - Silver
tags:
  - C++
  - 그래프 이론
  - 그래프 탐색
  - 너비 우선 탐색
  - 데이크스트라
  - 최단 경로
---

[문제 링크](https://www.acmicpc.net/problem/18352)\n\n---\n\n### 분류\n- 그래프 이론, 그래프 탐색, 너비 우선 탐색, 최단 경로, 데이크스트라\n\n### 문제 설명\n<p>어떤 나라에는 1번부터 <em>N</em>번까지의 도시와 <em>M</em>개의 단방향 도로가 존재한다. 모든 도로의 거리는 1이다.</p>

<p>이 때 특정한 도시 <em>X</em>로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 <em>K</em>인 모든 도시들의 번호를 출력하는 프로그램을 작성하시오. 또한 출발 도시 <em>X</em>에서 출발 도시 <em>X</em>로 가는 최단 거리는 항상 0이라고 가정한다.</p>

<p>예를 들어 <em>N</em>=4, <em>K</em>=2, <em>X</em>=1일 때 다음과 같이 그래프가 구성되어 있다고 가정하자.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/a5e311d7-7ce4-4638-88a5-3665fb4459e5/-/preview/" style="height: 249px; width: 250px;"></p>

<p style="text-align: justify;">이 때 1번 도시에서 출발하여 도달할 수 있는 도시 중에서, 최단 거리가 2인 도시는 4번 도시 뿐이다.  2번과 3번 도시의 경우, 최단 거리가 1이기 때문에 출력하지 않는다.</p>\n\n### 입력\n<p>첫째 줄에 도시의 개수 <em>N</em>, 도로의 개수 <em>M</em>, 거리 정보 <em>K</em>, 출발 도시의 번호 <em>X</em>가 주어진다. (2 ≤ <em>N </em>≤ 300,000, 1 ≤ <em>M </em>≤ 1,000,000, 1 ≤ <em>K </em>≤ 300,000, 1 ≤ <em>X </em>≤ <em>N</em>) 둘째 줄부터 <em>M</em>개의 줄에 걸쳐서 두 개의 자연수 <em>A</em>, <em>B</em>가 공백을 기준으로 구분되어 주어진다. 이는 <em>A</em>번 도시에서 <em>B</em>번 도시로 이동하는 단방향 도로가 존재한다는 의미다. (1 ≤ <em>A</em>, <em>B </em>≤ <em>N</em>) 단, <em>A</em>와 <em>B</em>는 서로 다른 자연수이다.</p>\n\n### 출력\n<p><em>X</em>로부터 출발하여 도달할 수 있는 도시 중에서, 최단 거리가 <em>K</em>인 모든 도시의 번호를 한 줄에 하나씩 오름차순으로 출력한다.</p>

<p>이 때 도달할 수 있는 도시 중에서, 최단 거리가 <em>K</em>인 도시가 하나도 존재하지 않으면 -1을 출력한다.</p>\n
## 💻 코드 (C++)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

vector<int> A[300001];  // 인접 리스트
int visited[300001];     // 방문 표시: -1 = 미방문, 0 이상 = 거리
vector<int> ans;         // 정답 저장
queue<int> q;

void BFS(int node) {
  visited[node] = 0;
  q.push(node);

  while (!q.empty()) {
    int now = q.front();
    q.pop();

    for (auto i : A[now]) {
      if (visited[i] == -1) {
        visited[i] = visited[now] + 1;
        q.push(i);
      }
    }
  }
}

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0);

  int n, m, k, x;
  cin >> n >> m >> k >> x;

  for (int i = 1; i <= n; i++) {
    visited[i] = -1;
  }

  for (int i = 0; i < m; i++) {
    int s, e;
    cin >> s >> e;
    A[s].push_back(e);
  }

  BFS(x);

  for (int i = 1; i <= n; i++) {
    if (visited[i] == k) {
      ans.push_back(i);
    }
  }

  if (ans.empty()) {
    cout << -1;
  } else {
    sort(ans.begin(), ans.end());
    for (int i : ans) cout << i << "\n";
  }

  return 0;
}

```
